<template>
    <div
        class="p-4 border border-dashed border-zinc-400 rounded-md min-h-[200px]"
        @dragover.prevent
        @drop="handleDrop"
    >
        <div class="flex justify-between items-center mb-4">
            <h2 class="font-semibold">선택된 대상</h2>
            <div class="flex gap-2">
                <button
                    v-if="tree.length"
                    @click="collapseAll"
                    class="text-xs px-2 py-1 bg-zinc-200 rounded hover:bg-zinc-300"
                >
                    모두 접기
                </button>
                <button
                    v-if="tree.length"
                    @click="expandAll"
                    class="text-xs px-2 py-1 bg-zinc-200 rounded hover:bg-zinc-300"
                >
                    모두 펼치기
                </button>
                <button
                    v-if="tree.length"
                    @click="clearTree"
                    class="text-xs px-2 py-1 bg-red-100 rounded hover:bg-red-200 text-red-700"
                >
                    모두 지우기
                </button>
            </div>
        </div>
        <div
            v-if="tree.length"
            class="overflow-auto max-h-[500px] border border-zinc-200 rounded p-2 bg-white"
        >
            <ul class="pl-2">
                <EnhancedTreeNode
                    v-for="(node, i) in tree"
                    :key="i"
                    :node="node"
                    :level="0"
                    :expanded="expandedState[node.id] || false"
                    @remove="removeNode"
                    @toggle-expand="toggleExpand"
                />
            </ul>
        </div>
        <div
            v-else
            class="flex flex-col items-center justify-center h-32 text-zinc-400 text-sm border-2 border-dashed border-zinc-300 rounded-lg bg-zinc-50"
        >
            <div class="mb-2">
                👈 왼쪽 조직도에서 드래그해서 여기로 놓으세요
            </div>
            <div class="text-xs text-zinc-500">
                팀, 부서 또는 개별 인원을 드래그할 수 있습니다
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref, type Ref, onMounted, provide } from "vue";
import EnhancedTreeNode from "@/components/TreeNode.vue";
import type { TreeNodeItem } from "@/types/tree";

const tree = ref<TreeNodeItem[]>([]);
const expandedState: Ref<Record<string, boolean>> = ref({});
provide("expandedState", expandedState);

const toggleExpand = (id: string): void => {
    expandedState.value[id] = !(expandedState.value[id] || false);
};

const expandAll = (): void => {
    traverseTree(tree.value, (node) => {
        if (node.children?.length) expandedState.value[node.id] = true;
    });
};

const collapseAll = (): void => {
    traverseTree(tree.value, (node) => {
        if (node.children?.length) expandedState.value[node.id] = false;
    });
};

const clearTree = (): void => {
    if (confirm("모든 선택 항목을 삭제하시겠습니까?")) {
        tree.value = [];
        expandedState.value = {};
    }
};

const traverseTree = (
    nodes: TreeNodeItem[],
    callback: (node: TreeNodeItem) => void
): void => {
    nodes.forEach((node) => {
        callback(node);
        if (node.children?.length) traverseTree(node.children, callback);
    });
};

const generateId = (type: string, name: string): string =>
    `${type}-${name.replace(/\s+/g, "-").toLowerCase()}`;

const extractNameAndPosition = (
    fullName: string
): { name: string; position: string } => {
    const match = fullName.match(/^(.+?)\s(.+?)$/);
    return match
        ? { name: match[1], position: match[2] }
        : { name: fullName, position: "" };
};

const findNodeById = (
    nodes: TreeNodeItem[],
    id: string
): TreeNodeItem | null => {
    for (const node of nodes) {
        if (node.id === id) return node;
        if (node.children?.length) {
            const found = findNodeById(node.children, id);
            if (found) return found;
        }
    }
    return null;
};

const removeNode = (id: string): void => {
    const topLevelIndex = tree.value.findIndex((node) => node.id === id);
    if (topLevelIndex !== -1) {
        tree.value.splice(topLevelIndex, 1);
        return;
    }
    const removeFromChildren = (nodes: TreeNodeItem[]): boolean => {
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (!node.children) continue;
            const childIndex = node.children.findIndex(
                (child) => child.id === id
            );
            if (childIndex !== -1) {
                node.children.splice(childIndex, 1);
                if (node.children.length === 0) node.children = [];
                return true;
            }
            if (node.children.length > 0 && removeFromChildren(node.children))
                return true;
        }
        return false;
    };
    removeFromChildren(tree.value);
};
// 멤버가 어떤 팀에도 속하지 않았는지 확인
const isIndependentMember = (memberName: string): boolean => {
    const nameOnly = extractNameAndPosition(memberName).name;
    const findMemberInChildren = (nodes: TreeNodeItem[]): boolean => {
        for (const node of nodes) {
            if (
                node.children?.some(
                    (child) =>
                        child.type === "member" &&
                        extractNameAndPosition(child.name).name === nameOnly
                )
            )
                return true;
            if (node.children?.length && findMemberInChildren(node.children))
                return true;
        }
        return false;
    };
    return !findMemberInChildren(tree.value);
};

interface DragDataMember {
    type: "member";
    name: string;
    path?: string[];
}
interface DragDataTeam {
    type: "team" | "department";
    name: string;
    members: string[];
    path?: string[];
}
interface DragDataCompany {
    type: "company";
    name: string;
    members: string[];
    path?: string[];
}
type DragData = DragDataMember | DragDataTeam | DragDataCompany;

const insertMemberToTeamByPath = (
    member: TreeNodeItem,
    path: string[]
): boolean => {
    let currentNodes = tree.value;
    let parent: TreeNodeItem | null = null;

    for (const segment of path) {
        const found = currentNodes.find(
            (n) =>
                (n.type === "team" || n.type === "department") &&
                n.name === segment
        );
        if (!found) return false;
        parent = found;
        if (!found.children) found.children = [];
        currentNodes = found.children;
    }

    if (!parent) return false;
    const exists = parent.children!.some((child) => child.id === member.id);
    if (!exists) parent.children!.push(member);
    return true;
};

const handleDrop = (event: DragEvent): void => {
    const data = event.dataTransfer?.getData("application/json");
    if (!data) return;
    try {
        const parsed = JSON.parse(data) as DragData;

        if (parsed.type === "member") {
            const { name, position } = extractNameAndPosition(parsed.name);
            const memberId = generateId("member", parsed.name);

            // 이미 독립적으로 추가된 멤버인지 확인
            const existingNode = findNodeById(tree.value, memberId);
            if (existingNode) return;

            // 이미 다른 팀에 포함된 멤버인지 확인
            if (!isIndependentMember(parsed.name)) return;
            // 멤버 추가
            const newNode: TreeNodeItem = {
                name: parsed.name,
                type: "member",
                id: memberId,
                position,
            };
            const inserted = parsed.path
                ? insertMemberToTeamByPath(newNode, parsed.path)
                : false;
            if (!inserted) tree.value.push(newNode);
            expandedState.value[memberId] = true;
        } else if (parsed.type === "team" || parsed.type === "department") {
            const teamId = generateId(parsed.type, parsed.name);

            // 이미 추가된 팀인지 확인
            if (findNodeById(tree.value, teamId)) return;

            // 팀에 속한 멤버 중 중복을 제거
            const uniqueMembers = parsed.members.filter((member: string) =>
                isIndependentMember(member)
            );

            // 팀과 멤버 추가
            const memberNodes: TreeNodeItem[] = uniqueMembers.map(
                (member: string) => {
                    const memberId = generateId("member", member);
                    const existing = findNodeById(tree.value, memberId);
                    if (existing) {
                        removeNode(memberId);
                        delete expandedState.value[memberId];
                        existing.path = parsed.path || [parsed.name];

                        return existing;
                    } else {
                        const { position } = extractNameAndPosition(member);
                        return {
                            name: member,
                            type: "member",
                            id: memberId,
                            position,
                            path: [parsed.name],
                        };
                    }
                }
            );

            const newNode: TreeNodeItem = {
                name: parsed.name,
                type: parsed.type,
                id: teamId,
                children: memberNodes,
                path: parsed.path || [parsed.name], // ✅ 계층 경로 보존
            };

            tree.value.push(newNode);
            expandedState.value[teamId] = true;
        } else if (parsed.type === "company") {
            const companyId = generateId("company", parsed.name);
            if (findNodeById(tree.value, companyId)) return;
            const uniqueMembers = parsed.members.filter(
                (member: string) =>
                    !findNodeById(tree.value, generateId("member", member))
            );
            const memberNodes: TreeNodeItem[] = uniqueMembers.map(
                (member: string) => {
                    const { position } = extractNameAndPosition(member);
                    return {
                        name: member,
                        type: "member",
                        id: generateId("member", member),
                        position,
                        path: [parsed.name],
                    };
                }
            );

            const newNode: TreeNodeItem = {
                name: parsed.name,
                type: "company",
                id: companyId,
                children: memberNodes,
            };

            tree.value.push(newNode);
            expandedState.value[companyId] = true;
        }
    } catch (err) {
        console.error("❌ 드롭 데이터 파싱 오류:", err);
    }
};

onMounted(() => {
    expandAll();
});
</script>
